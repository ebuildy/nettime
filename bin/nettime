#!/usr/bin/env node

'use strict'

const commander = require('commander')
const nettime = require('..')
const { version, description } = require('../package.json')
const print = require('../lib/printer')
const readlineSync = require('readline-sync')

function collect (value, result) {
  result.push(value)
  return result
}

commander
  .version(version)
  .description(description)
  .usage('[options] <URL>')
  .option('-0, --http1.0', 'use HTTP 1.0')
  .option('--http1.1', 'use HTTP 1.1 (default)')
  .option('--http2', 'use HTTP 2')
  .option('-c, --connect-timeout <ms>', 'maximum time to wait for a connection', parseInt)
  .option('-d, --data <data>', 'data to be sent using the POST verb')
  .option('-f, --format <format>', 'set output format: text, json, raw')
  .option('-H, --header <header>', 'send specific HTTP header', collect, [])
  .option('-i, --include', 'include response headers in the output')
  .option('-I, --head', 'use HEAD verb to get document info only')
  .option('-k, --insecure', 'ignore certificate errors')
  .option('-o, --output <file>', 'write the received data to a file')
  .option('-t, --time-unit <unit>', 'set time unit: ms, s+ns')
  .option('-u, --user <credentials>', 'credentials for Basic Authentication')
  .option('-X, --request <verb>', 'specify HTTP verb to use for the request')
  .on('--help', function () {
    console.log()
    console.log('  The default output format is "text" and time unit "ms". Other options')
    console.log('  are compatible with curl. Timings are printed to the standard output.')
    console.log()
    console.log('  Examples:')
    console.log()
    console.log('    $ nettime https://www.google.com')
    console.log('    $ nettime -f json https://www.github.com')
  })
  .parse(process.argv)

const url = commander.args[0]
if (!url) {
  commander.help()
}

const timeUnit = commander.timeUnit || 'ms'
if (['ms', 's+ns'].indexOf(timeUnit) < 0) {
  console.error(`Invalid time unit: "${timeUnit}". Valid values are "ms", and "s+ns".`)
  process.exit(1)
}

const formatters = {
  json: result => {
    if (timeUnit !== 's+ns') {
      convertToMilliseconds(result.timings)
    }
    return result
  },
  raw: result => JSON.stringify(result),
  text: ({ timings, httpVersion, statusCode, statusMessage }) => {
    print(timings, timeUnit)
    return `Response: HTTP/${httpVersion} ${statusCode} ${statusMessage}`
  }
}

const format = commander.format || 'text'
const formatter = formatters[format]
if (!formatter) {
  console.error(`Invalid format: "${format}". Valid formats are "text", "json" and "raw".`)
  process.exit(1)
}

const headers = commander.header.reduce(function (result, header) {
  const colon = header.indexOf(':')
  if (colon > 0) {
    result[header.substr(0, colon).trim().toLowerCase()] =
      header.substr(colon + 1).trim()
  }
  return result
}, {})

let credentials = commander.user
if (credentials) {
  const colon = credentials.indexOf(':')
  let username, password
  if (colon > 0) {
    username = credentials.substr(0, colon)
    password = credentials.substr(colon + 1)
  } else {
    username = credentials
    password = readlineSync.question('Password: ', {
      hideEchoBack: true
    })
  }
  credentials = {
    username: username,
    password: password
  }
}

nettime({
  url: url,
  credentials: credentials,
  data: commander.data,
  failOnOutputFileError: false,
  headers: headers,
  httpVersion: commander.http2 ? '2.0' : commander['http1.0'] ? '1.0' : '1.1',
  includeHeaders: commander.include,
  method: commander.request ||
    (commander.head ? 'HEAD' : commander.data ? 'POST' : 'GET'),
  outputFile: commander.output,
  rejectUnauthorized: !commander.insecure,
  timeout: commander.connectTimeout
})
  .then(result => console.log(formatter(result)))
  .catch(({ message }) => {
    console.error(message)
    process.exitCode = 1
  })

function convertToMilliseconds (timings) {
  const getMilliseconds = nettime.getMilliseconds
  for (const timing in timings) {
    timings[timing] = getMilliseconds(timings[timing])
  }
}
