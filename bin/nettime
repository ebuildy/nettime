#!/usr/bin/env node

'use strict'

const commander = require('commander')
const nettime = require('..')
const pkg = require('../package.json')
const print = require('../lib/printer')
const readlineSync = require('readline-sync')

function collect (value, result) {
  result.push(value)
  return result
}

commander.version(pkg.version)
  .description(pkg.description)
  .usage('[options] <URL>')
  .option('-0, --http1.0', 'use HTTP 1.0')
  .option('--http1.1', 'use HTTP 1.1 (default)')
  .option('--http2', 'use HTTP 2')
  .option('-c, --connect-timeout <ms>', 'maximum time to wait for a connection', parseInt)
  .option('-d, --data <data>', 'data to be sent using the POST verb')
  .option('-f, --format <format>', 'set output format: text, json')
  .option('-H, --header <header>', 'send specific HTTP header', collect, [])
  .option('-i, --include', 'include response headers in the output')
  .option('-I, --head', 'use HEAD verb to get document info only')
  .option('-k, --insecure', 'ignore certificate errors')
  .option('-o, --output <file>', 'write the received data to a file')
  .option('-t, --time-unit <unit>', 'set time unit: ms, s+ns')
  .option('-u, --user <credentials>', 'credentials for Basic Authentication')
  .option('-X, --request <verb>', 'specify HTTP verb to use for the request')

commander.on('--help', function () {
  console.log()
  console.log('  The default output format is "text" and time unit "ms". Other options')
  console.log('  are compatible with curl. Timings are printed to the standard output.')
  console.log()
  console.log('  Examples:')
  console.log()
  console.log('    $ nettime https://www.google.com')
  console.log('    $ nettime -f json https://www.github.com')
})

commander.parse(process.argv)
const url = commander.args[0]
if (!url) {
  commander.help()
}

const headers = commander.header.reduce(function (result, header) {
  const colon = header.indexOf(':')
  if (colon > 0) {
    result[header.substr(0, colon).trim().toLowerCase()] =
      header.substr(colon + 1).trim()
  }
  return result
}, {})

let credentials = commander.user
if (credentials) {
  let colon = credentials.indexOf(':')
  let username, password
  if (colon > 0) {
    username = credentials.substr(0, colon)
    password = credentials.substr(colon + 1)
  } else {
    username = credentials
    password = readlineSync.question('Password: ', {
      hideEchoBack: true
    })
  }
  credentials = {
    username: username,
    password: password
  }
}

nettime({
  url: url,
  credentials: credentials,
  data: commander.data,
  failOnOutputFileError: false,
  headers: headers,
  httpVersion: commander['http2'] ? '2.0' : commander['http1.0'] ? '1.0' : '1.1',
  includeHeaders: commander.include,
  method: commander.request || (commander.head ? 'HEAD'
    : commander.data ? 'POST' : 'GET'),
  outputFile: commander.output,
  rejectUnauthorized: !commander.insecure,
  timeout: commander.connectTimeout
})
  .then(function (result) {
    const timeUnit = commander.timeUnit
    if (commander.format === 'json') {
      if (timeUnit !== 's+ns') {
        convertToMilliseconds(result.timings)
      }
      console.log(result)
    } else {
      print(result.timings, timeUnit)
      console.log('Response: HTTP/' + result.httpVersion, result.statusCode,
        result.statusMessage)
    }
  })
  .catch(function (error) {
    console.error(error.message)
    process.exitCode = 1
  })

function convertToMilliseconds (timings) {
  const getMilliseconds = nettime.getMilliseconds
  for (let timing in timings) {
    timings[timing] = getMilliseconds(timings[timing])
  }
}
