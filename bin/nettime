#!/usr/bin/env node

const commander = require('commander')
const nettime = require('..')
const { version, description } = require('../package.json')
const printTimings = require('../lib/printer')
const readlineSync = require('readline-sync')

commander
  .version(version)
  .description(description)
  .usage('[options] <URL>')
  .option('-0, --http1.0', 'use HTTP 1.0')
  .option('--http1.1', 'use HTTP 1.1 (default)')
  .option('--http2', 'use HTTP 2')
  .option('-c, --connect-timeout <ms>', 'maximum time to wait for a connection', parseInt)
  .option('-d, --data <data>', 'data to be sent using the POST verb')
  .option('-f, --format <format>', 'set output format: text, json, raw')
  .option('-H, --header <header>', 'send specific HTTP header', collect, [])
  .option('-i, --include', 'include response headers in the output')
  .option('-I, --head', 'use HEAD verb to get document info only')
  .option('-k, --insecure', 'ignore certificate errors')
  .option('-o, --output <file>', 'write the received data to a file')
  .option('-t, --time-unit <unit>', 'set time unit: ms, s+ns')
  .option('-u, --user <credentials>', 'credentials for Basic Authentication')
  .option('-X, --request <verb>', 'specify HTTP verb to use for the request')
  .on('--help', () => {
    console.log()
    console.log('  The default output format is "text" and time unit "ms". Other options')
    console.log('  are compatible with curl. Timings are printed to the standard output.')
    console.log()
    console.log('  Examples:')
    console.log()
    console.log('    $ nettime https://www.google.com')
    console.log('    $ nettime -f json https://www.github.com')
  })
  .parse(process.argv)

const url = commander.args[0]
if (!url) {
  commander.help()
}

const timeUnit = commander.timeUnit || 'ms'
if (['ms', 's+ns'].indexOf(timeUnit) < 0) {
  console.error(`Invalid time unit: "${timeUnit}". Valid values are "ms", and "s+ns".`)
  process.exit(1)
}

const formatters = {
  json: result => {
    if (timeUnit !== 's+ns') {
      convertToMilliseconds(result.timings)
    }
    return result
  },
  raw: result => JSON.stringify(result),
  text: ({ timings, httpVersion, statusCode, statusMessage }) =>
    printTimings(timings, timeUnit) +
    `\nResponse: HTTP/${httpVersion} ${statusCode} ${statusMessage}`
}

const format = commander.format || 'text'
const formatter = formatters[format]
if (!formatter) {
  console.error(`Invalid format: "${format}". Valid formats are "text", "json" and "raw".`)
  process.exit(1)
}

const headers = commander.header.reduce((result, header) => {
  const colon = header.indexOf(':')
  if (colon > 0) {
    const name = header
      .substr(0, colon)
      .trim()
      .toLowerCase()
    const value = header
      .substr(colon + 1)
      .trim()
    result[name] = value
  }
  return result
}, {})

let credentials = commander.user
if (credentials) {
  const colon = credentials.indexOf(':')
  let username, password
  if (colon > 0) {
    username = credentials.substr(0, colon)
    password = credentials.substr(colon + 1)
  } else {
    username = credentials
    password = readlineSync.question('Password: ', { hideEchoBack: true })
  }
  credentials = { username, password }
}

const {
  connectTimeout: timeout, data, head, include: includeHeaders, insecure,
  output: outputFile, request
} = commander
const httpVersion = commander.http2 ? '2.0' : commander['http1.0'] ? '1.0' : '1.1'
const method = request || (head ? 'HEAD' : data ? 'POST' : 'GET')
const failOnOutputFileError = false
const rejectUnauthorized = !insecure

nettime({
  httpVersion,
  method,
  url,
  credentials,
  headers,
  data,
  failOnOutputFileError,
  includeHeaders,
  outputFile,
  rejectUnauthorized,
  timeout
})
  .then(result => console.log(formatter(result)))
  .catch(({ message }) => {
    console.error(message)
    process.exitCode = 1
  })

function collect (value, result) {
  result.push(value)
  return result
}

function convertToMilliseconds (timings) {
  const getMilliseconds = nettime.getMilliseconds
  for (const timing in timings) {
    timings[timing] = getMilliseconds(timings[timing])
  }
}
